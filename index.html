<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>DLA - datastore</title>

    <meta name="description" content="DataLoadingAdministration console - datastore implementation">
    <meta name="author" content="Marek Gerhart">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/mge.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write('<link rel="stylesheet" href="css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
    <h1>DLA datastore implementation</h1>

    <p>
        <small><strong>Marek Gerhart</strong> @ GoodData 2013</small>
    </p>
</section>

<section>
    <h2>Agenda</h2>
    <ul>
        <li class="fragment">Requirements - what we expect from datastore</li>        
        <li class="fragment">Implementation</li>
    </ul>
    <aside class="notes">
        Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open
        the
        speaker notes window (hit 's' on your keyboard).
    </aside>
</section>

<section>
    <h2>Requirements</h2>
    <ul>
        <li class="fragment">Model - single source of truth (no synchronization issues between models)</li>
        <li class="fragment">Refreshing - refresh models every couple of minutes/seconds</li>                
        <li class="fragment">Partial saving - multiple forms for different parts of model</li>
        <li class="fragment">Deleting - don't freak out if resource/model is deleted on the backend</li>
        <li class="fragment">Proper loading status indication - loading/refreshing/saving/saved (for 15 secs),...</li>
    </ul>
</section>

<!-- Example of nested vertical slides -->
<section>
    <section>
        <h2>Model - single source of truth</h2>
    </section>
    <section>        
        <h3>Data resources:</h3>
        <ul>
            <li>/gdc/projects/{projectId}/dataload/processes/</li>
            <li>/gdc/projects/{projectId}/schedules</li>        
            <li>/gdc/projects/{projectId}/schedules/{scheduleId}/executions</li>
            <li>/gdc/projects/{projectId}/dataload/processes/{processesId}/notificationRules</li>        
        </ul>
    </section> 
    <section>        
        <h3>Single grouping bootstrap resource</h3>
        <ul>
            <li>/gdc/app/account/profile/{profileId}/dataload/processesView</li>
        </ul>
<br><br>
        <p class="left">* serves for listing all processes of all project for user. It also contains some partial
            information about schedule and last execution.</p>

            <br><br>
        <p class="left">* it is used to load all necessary data to display home page (list of processes) and main menu.</p>   
    </section>  
    <section>        
        <h3>Keep models in sync</h3>
        <p>The crucial thing is to keep models in sync - display the same information in process list that are in chedule detail</p>
    </section> 
</section>

<section>    
        <h2>Refreshing</h2>
        <ul>
            <li>models should refresh themselves every couple of seconds</li>
            <li>refresh should be graceful - no flickering, user shouldn't know that something is going on (besides changed values)</li>
            <li>refresh can't destroy form if user is currently editing model</li>
            <li>other properties of model (the ones that are not being edited) should be refreshed if possible</li>
            <li>use proper loading status handling - REFRESH for refreshing (different than LOADING)</li>
        </ul>    
</section>  
<section>
    
        <h3>Saving</h3>
        <ul>
            <li>model can have multiple forms for editing (different forms for different property groups)</li>
            <li>handle refresh during editing</li>
            <li>each form has its own validations</li>
        </ul>
</section>    

<section>    
        <h3>Deleting</h3>
        <ul>
            <li>Model can be deleted from application</li>
            <li>Model can be deleted on backend (during refresh)</li>
        </ul>
</section> 

<section>    
        <h3>Implementation</h3>
</section> 


<section>    
    <section> 
        <h3>Datastore</h3>
        <ul>
            <li>there is one datastore that handles caching and delegates backend communication + materialization to proper adapter (based on model type)</li>
            <li>caching is only handled in datastore - adapters know nothing about cache</li>
            <li>when accessing model, user get it whether it is loaded or not (it can be filled later)</li>
            <li>returns always the same instance of model no matter what (even in lists)</li>
            <li>lists items are cached too</li>
        </ul>
    </section> 

    <section> 
        <h3>adapters</h3>
        <ul>
            <li>handle backend communication</li>
            <li>handle materialization - populate model from json response</li>
            <li>BOOTSTRAP/FULL materialization mode</li>
            <li>if json payload contains related model(resource), delegate materialiation on datastore (which will delegate it on proper adapter)</li>
            <li>model has basic onLoaded/onSaved/onError handlers that cen register callback based on load state change</li>
            <li>handle model array materialization - remove items removed on backend (remove from related lists + mark as Deleted)</li>
        </ul>
    </section>   
</section> 

<section>    
        <h3>Refreshing</h3>
        <ul>
            <li>controller mixin where refreshModel method must be overriden (with specified query etc)</li>
            <li>activated from router enable/disable when entering/leaving route</li>
            <li>configurable timeout</li>
            <li>there are some scenarios when refreshing is not possible - model is loading/saving/refreshing already</li>
        </ul>
</section> 

<section>    
        <h3>Saving</h3>
        <ul>
            <li>controller mixin for form controllers</li>
            <li>route can contain multiple such controllers</li>
            <li>such controller get whole model as content and creates copy of properties that is handles (edit)</li>
            <li>actually it creates 2 copies to handle refreshing</li>
            <li>it also contains actual state (model is being modified/saving/saved)</li>
        </ul>
</section> 

<section>    
        <h3>Deleting</h3>
        <ul>
            <li>when model is deleted it is removed from all related lists (go through cached lists) and marked as deleted</li>
            <li>model stays in cache</li>
            <li>set DELETED status</li>
            <li>user can register callback on onDeleted event on model</li>
        </ul>
</section> 


<section>
    <h3>That's it. Any Q?</h3>
</section>
</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() {
                return !document.body.classList;
            } },
            { src: 'plugin/markdown/showdown.js', condition: function() {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'plugin/markdown/markdown.js', condition: function() {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() {
                hljs.initHighlightingOnLoad();
            } },
            { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() {
                return !!document.body.classList;
            } },
            { src: 'plugin/notes/notes.js', async: true, condition: function() {
                return !!document.body.classList;
            } }
            // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
            // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
    });

</script>

</body>
</html>
